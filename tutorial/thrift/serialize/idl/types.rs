// Autogenerated by Thrift Compiler (0.16.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EnumType(pub i32);

impl EnumType {
  pub const ZERO: EnumType = EnumType(0);
  pub const ONE: EnumType = EnumType(1);
  pub const TWO: EnumType = EnumType(2);
  pub const THREE: EnumType = EnumType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ZERO,
    Self::ONE,
    Self::TWO,
    Self::THREE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EnumType> {
    let enum_value = i_prot.read_i32()?;
    Ok(EnumType::from(enum_value))
  }
}

impl From<i32> for EnumType {
  fn from(i: i32) -> Self {
    match i {
      0 => EnumType::ZERO,
      1 => EnumType::ONE,
      2 => EnumType::TWO,
      3 => EnumType::THREE,
      _ => EnumType(i)
    }
  }
}

impl From<&i32> for EnumType {
  fn from(i: &i32) -> Self {
    EnumType::from(*i)
  }
}

impl From<EnumType> for i32 {
  fn from(e: EnumType) -> i32 {
    e.0
  }
}

impl From<&EnumType> for i32 {
  fn from(e: &EnumType) -> i32 {
    e.0
  }
}

pub type StrType = String;

//
// UnionType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum UnionType {
  VarI16(i16),
  VarI32(i32),
}

impl UnionType {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UnionType> {
    let mut ret: Option<UnionType> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          if ret.is_none() {
            ret = Some(UnionType::VarI16(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_i32()?;
          if ret.is_none() {
            ret = Some(UnionType::VarI32(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote UnionType"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote UnionType"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UnionType");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      UnionType::VarI16(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("var_i16", TType::I16, 1))?;
        o_prot.write_i16(f)?;
        o_prot.write_field_end()?;
      },
      UnionType::VarI32(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("var_i32", TType::I32, 2))?;
        o_prot.write_i32(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StructType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StructType {
  pub var_bool: Option<bool>,
  pub var_byte: Option<i8>,
  pub var_i16: Option<i16>,
  pub var_i32: Option<i32>,
  pub var_i64: Option<i64>,
  pub var_double: Option<OrderedFloat<f64>>,
  pub var_string: Option<String>,
  pub var_binary: Option<Vec<u8>>,
  pub var_string_type: Option<StrType>,
  pub var_string_list: Option<Vec<String>>,
  pub var_binary_list: Option<Vec<Vec<u8>>>,
  pub var_string_set: Option<BTreeSet<String>>,
  pub var_string_binary_map: Option<BTreeMap<String, Vec<u8>>>,
  pub var_enum: Option<EnumType>,
  pub var_enum_set: Option<BTreeSet<EnumType>>,
  pub var_union: Option<UnionType>,
  pub var_required_i32: i32,
  pub var_optional_i32: Option<i32>,
}

impl StructType {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F18>(var_bool: F1, var_byte: F2, var_i16: F3, var_i32: F4, var_i64: F5, var_double: F6, var_string: F7, var_binary: F8, var_string_type: F9, var_string_list: F10, var_binary_list: F11, var_string_set: F12, var_string_binary_map: F13, var_enum: F14, var_enum_set: F15, var_union: F16, var_required_i32: i32, var_optional_i32: F18) -> StructType where F1: Into<Option<bool>>, F2: Into<Option<i8>>, F3: Into<Option<i16>>, F4: Into<Option<i32>>, F5: Into<Option<i64>>, F6: Into<Option<OrderedFloat<f64>>>, F7: Into<Option<String>>, F8: Into<Option<Vec<u8>>>, F9: Into<Option<StrType>>, F10: Into<Option<Vec<String>>>, F11: Into<Option<Vec<Vec<u8>>>>, F12: Into<Option<BTreeSet<String>>>, F13: Into<Option<BTreeMap<String, Vec<u8>>>>, F14: Into<Option<EnumType>>, F15: Into<Option<BTreeSet<EnumType>>>, F16: Into<Option<UnionType>>, F18: Into<Option<i32>> {
    StructType {
      var_bool: var_bool.into(),
      var_byte: var_byte.into(),
      var_i16: var_i16.into(),
      var_i32: var_i32.into(),
      var_i64: var_i64.into(),
      var_double: var_double.into(),
      var_string: var_string.into(),
      var_binary: var_binary.into(),
      var_string_type: var_string_type.into(),
      var_string_list: var_string_list.into(),
      var_binary_list: var_binary_list.into(),
      var_string_set: var_string_set.into(),
      var_string_binary_map: var_string_binary_map.into(),
      var_enum: var_enum.into(),
      var_enum_set: var_enum_set.into(),
      var_union: var_union.into(),
      var_required_i32,
      var_optional_i32: var_optional_i32.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StructType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<i8> = Some(0);
    let mut f_3: Option<i16> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<Vec<u8>> = Some(Vec::new());
    let mut f_9: Option<StrType> = Some("".to_owned());
    let mut f_10: Option<Vec<String>> = Some(Vec::new());
    let mut f_11: Option<Vec<Vec<u8>>> = Some(Vec::new());
    let mut f_12: Option<BTreeSet<String>> = Some(BTreeSet::new());
    let mut f_13: Option<BTreeMap<String, Vec<u8>>> = Some(BTreeMap::new());
    let mut f_14: Option<EnumType> = None;
    let mut f_15: Option<BTreeSet<EnumType>> = Some(BTreeSet::new());
    let mut f_16: Option<UnionType> = None;
    let mut f_17: Option<i32> = None;
    let mut f_18: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bytes()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_bytes()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        12 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_2 = i_prot.read_string()?;
            val.insert(set_elem_2);
          }
          i_prot.read_set_end()?;
          f_12 = Some(val);
        },
        13 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = i_prot.read_string()?;
            let map_val_4 = i_prot.read_bytes()?;
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_13 = Some(val);
        },
        14 => {
          let val = EnumType::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        15 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<EnumType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_5 = EnumType::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_5);
          }
          i_prot.read_set_end()?;
          f_15 = Some(val);
        },
        16 => {
          let val = UnionType::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i32()?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("StructType.var_required_i32", &f_17)?;
    let ret = StructType {
      var_bool: f_1,
      var_byte: f_2,
      var_i16: f_3,
      var_i32: f_4,
      var_i64: f_5,
      var_double: f_6,
      var_string: f_7,
      var_binary: f_8,
      var_string_type: f_9,
      var_string_list: f_10,
      var_binary_list: f_11,
      var_string_set: f_12,
      var_string_binary_map: f_13,
      var_enum: f_14,
      var_enum_set: f_15,
      var_union: f_16,
      var_required_i32: f_17.expect("auto-generated code should have checked for presence of required fields"),
      var_optional_i32: f_18,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StructType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.var_bool {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_bool", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.var_byte {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_byte", TType::I08, 2))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.var_i16 {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_i16", TType::I16, 3))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.var_i32 {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_i32", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.var_i64 {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_i64", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.var_double {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_double", TType::Double, 6))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_string", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_binary {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_binary", TType::String, 8))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_string_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_string_type", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_string_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_string_list", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_binary_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_binary_list", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_string_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_string_set", TType::Set, 12))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_string_binary_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_string_binary_map", TType::Map, 13))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_enum {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_enum", TType::I32, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_enum_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_enum_set", TType::Set, 15))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.var_union {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_union", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("var_required_i32", TType::I32, 17))?;
    o_prot.write_i32(self.var_required_i32)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.var_optional_i32 {
      o_prot.write_field_begin(&TFieldIdentifier::new("var_optional_i32", TType::I32, 18))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OutterStructType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct OutterStructType {
  pub req: Option<StructType>,
}

impl OutterStructType {
  pub fn new<F1>(req: F1) -> OutterStructType where F1: Into<Option<StructType>> {
    OutterStructType {
      req: req.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OutterStructType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StructType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StructType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OutterStructType {
      req: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OutterStructType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.req {
      o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for OutterStructType {
  fn default() -> Self {
    OutterStructType{
      req: None,
    }
  }
}

//
// ExceptionType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExceptionType {
  pub msg: Option<String>,
}

impl ExceptionType {
  pub fn new<F1>(msg: F1) -> ExceptionType where F1: Into<Option<String>> {
    ExceptionType {
      msg: msg.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExceptionType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExceptionType {
      msg: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExceptionType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ExceptionType {
  fn default() -> Self {
    ExceptionType{
      msg: Some("".to_owned()),
    }
  }
}

impl Error for ExceptionType {}

impl From<ExceptionType> for thrift::Error {
  fn from(e: ExceptionType) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ExceptionType {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw ExceptionType")
  }
}

pub const GLOBAL_CONST_VAR_STRING: &str = "123";

